Java内存模型总结

* 从硬件层面来看

	运行中的程序数据储存会在三个地方

	** CPU（一个或多个）
	储存待计算的数据，储存在寄存器中

	** 缓存（多级缓存）
	储存刚使用过，或者使用频率比较高的数据

	** 内存
	储存所有当前运行程序所需要的数据



* 从JMM来看内存模型

	JMM 将储存划分为两种区域，堆与线程栈。

	** 线程栈
	每个线程都有其对应的线程栈，线程栈之间的数据不能互通。线程栈中只能保存：临时基本变量和对象的引用（此处的引用并不是储存对象的内存地址，而是一种别名的概念）

	** 堆
	一个进程（实际上是一个JVM）里只有一个堆，这个堆里存放的是所有动态分配的对象和对象的成员变量

* 内存模型的三种特性

	** 原子性
	原子性是指在执行一个操作的过程中，要么执行完成，要么不执行（类似于事务），不会被中途打断，如下：

		*** 我们进行的i++的操作及时不具有原子性的，计算机运行的时候，实际上是分成了这三个步骤
		   1.获取i的值
		   2.i+1
		   3.将i+1复制给i

		   这样的三个步骤每一个都是具有原子性的，因为他们的操作不会被其他操作影响

	** 可见性
	
	可见性个人理解包含两个地方，
	从JMM来看，同一线程栈内的数据是可见的，但是不同线程栈之间的数据不可见，互相访问不到

	从硬件看，某一线程的数据一般会从缓存中拿取副本，但是如果内存中的该数据有被其他线程锁改变
	那么缓存副本还会是原有数据，这是不可见的，如果使用了volatile关键字，数据修改会直接写入内存
	，其他线程栈中的缓存拷贝也会失效。


	** 有序性
	有序性是指方法执行的顺序是有序的，但是一般为了增强CPU的性能，一般在编译时进行指令重排序，编译器会将对相同变量操作的语句放在一起，例如：

	int a = 20;
	int b = 30;
	a = 60;

	但是实际上的执行顺序可能是：

	int a = 20;
	a = 60;
	int b = 30;
	
	因为这样可以减少CPU从缓存重复拿取数据所浪费的时间。

	volatile关键字可以使相关变量不进行指令重排序






