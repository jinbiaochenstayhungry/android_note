AES加密方式研究

* AES加密是对称加密 128 192 256 分别表示密钥的长度

* AES的加密方式会将明文拆分成不同的块进行加密，例如一个256 位的数据用128的密钥加密，则分成

	明文1（128位）    明文2（128位）

	加密

	密文1（128位）    密文2（128位）


* 填充：如果明文不是128位（16字节）的则需要填充，即在明文某个地方补充到16个字节整数倍的长度，加解密时需要采用同样的填充方式，否则无法解密成功，以下是几种填充方式

	** NoPadding
	不进行填充，但是这里要求明文必须要是16个字节的整数倍，这个可以使用者本身自己去实现填充，除了该种模式以外的其他填充模式，如果已经是16个字节的数据的话，会再填充一个16字节的数据

	** PKCS5Padding（默认）
	在明文的末尾进行填充，填充的数据是当前和16个字节相差的数量，例如：
	  未填充明文
	1，2，3，4，5，6，7，8，9，10，11

	  填充明文（缺少五个满足16个字节）
	1，2，3，4，5，6，7，8，9，10，11，5，5，5，5，5

	** ISO10126Padding
	在明文的末尾进行填充，当前和16个字节相差的数量填写在最后，其余字节填充随机数，例如：
	  未填充明文
	1，2，3，4，5，6，7，8，9，10，11

	  填充明文（缺少五个满足16个字节）
	1，2，3，4，5，6，7，8，9，10，11，c，b，4，1，5

* 模式，模式是需要制定AES对明文进行加密时使用的模式（这里并不涉及具体的加密方法，只是加密步骤上的不同模式，在加解密时同样需要相同的模式，否则无法成功），一共提供了五种模式，模式的基本原理是近似的，但是细节上会有一些变化，如下：

	** ECB模式（默认）电码本模式 Electronic Codebook Book

	这个模式是默认的，就只是根据密钥的位数，将数据分成不同的块进行加密，加密完成后，再将加密后的数据拼接起来，过程如下：

	明文（64字节） 密钥（16字节）

	明文1（16字节）  明文2（16字节）  明文3（16字节）  明文4（16字节）

	密文1（16字节）  密文2（16字节）  密文3（16字节）  密文4（16字节）

	密文（64字节）

	优点：简单、速度快、可并行
	缺点：如果明文块相同，则生成的密文块也相同，这样会导致安全性降低


	** CBC模式   密码分组链接模式 Cipher Block Chaining

	为了解决ECB模式的密文块相同的缺点，CBC的模式引入了一个初始向量概念，该向量必须是一个与密钥长度相等的数据，在第一次加密前，会使用初始化向量与第一块数据做异或运算，生成的新数据再进行加密，加密第二块之前，会拿第一块的密文数据与第二块明文进行异或运算后再进行加密，以此类推，解密时也是在解密后，进行异或运算，生成最终的明文。过程如下：

	明文（63字节） 密钥 （16字节） 初始向量iv（16字节）

	  明文1（16字节） 明文2（16字节） 明文3（16字节） 明文4+一个0（16字节） 

	异或  +初始向量        +密文1         +密文2         +密文3

	  密文1（16字节） 密文2（16字节） 密文3（16字节） 密文4（16字节） 

	密文（64字节）

	这里需要注意如下几点：
	1.向量必须是一个与密钥长度相等的数据
	2.由于在加密前和解密后都会做异或运算，因此我们的明文可以不用补全，不是16个字节的倍数也可以，CBC中会自动用0补全进行异或运算
	3.在解密时是解密后才会再做异或运算，保证数据解密成功
	4.由于自动进行了补全，所以解密出的数据也会在后面补全0，因此获取到数据时，需要将末尾的0去除，或者根据源数据长度来截取解密后的数据

	优点：每次加密密钥不同，加强了安全性

	CBC的方式解决了EBC的缺点，但是也有其缺点：
	1.加密无法并行运算，但是解密可以并行，必须在前一个块加密完成后，才能加密后块，并且也需要填充0在后面，所以并不适合流数据（不适合的原因可能是，需要满足128位的数据之后才能进行加密，这样后面才不会有0的补全）
	2.如果前一个数据加密错误，那么后续的数据都是错的了
	3.两端需要同时约定初始向量iv


	** CFB模式： 密码反馈模式 Cipher FeedBack
	这个模式只使用了加密方法，原理是用到了一个数值异或运算之后再进行一次异或运算，值不改变的原理。并且在加密的时候，如果数据并不满足一个密钥的字节，那么只做保存，待满足一个密钥的字节后再进行加密 过程如下：

	加密：

	明文（260个字节） iv（128个字节）

	明文1（128个字节）    明文2（128个字节）      明文3（4个字节）

	（iv+key）异或 明文1 （密文1+key）异或 明文1  （密文1+key）异或明文3

	密文1（128个字节）     密文2（128个字节）      密文3（4个字节）


	解密：

	密文（260个字节） iv（128个字节）密钥（128字节）

	密文1（128个字节）      密文2（128个字节）      密文3（4个字节）

	（iv+key）异或密文1   （密文1+key）异或密文2    （密文1+key）异或密文3

	明文1 （128个字节）     明文2  （128个字节）      明文3（4个字节）

	这里需要注意如下几点：
	1.加解密时会返回一个num，这个num表示还需要几个数字，才会使用上一个密文加密，否则一直使用上上一个
	2.加解密时也需要传入字符串的长度
	3.由于解密时使用的都是密文来进行解密，并没有使用上一次解密的明文，因此解密也可以并行
	4.由于CFB模式并不需要补全，或者一个完整的128字节才能加解密，综合第三点，所以适合流数据的传输。
	5.CFB模式不止有CFB128（即与密钥长度一致），还有CFB1 和CFB8 即加解密1或8位后，再调用一次加密器生成新的值，这样可以使加密更安全，但是就会处理更多的运算，CFB1的运算时间是CFB8的八倍 CFB128的128倍
	6.使用CFB128或者CFB8的时候传入的length单位是字节，CFB1是length的单位是位。
	7.使用CFB1和CFB8的时候，num值会始终为0

	优点:解密可同步，可以传入非16字节倍数的数据，适合流数据

	CFB模式当然也有一个缺点，解密的时候可以并行解密，但是加密的时候并不可以并行加密。并且也需要选择iv


	** OFB模式： 输出反馈模式 Output FeedBack
	该模式与CFB类似，但是是将iv或者上一个iv加密后的数据加密，生成的key与明文做异或运算，解密时采用的是同样的方法，利用了异或运算的对称性来进行加解密，除了这一点，其余与CFB一致

	加密/解密：

	CFB:
	（iv+key）异或 明文1 （密文1+key）异或 明文1       （密文1+key）异或明文3

	OFB
	（iv+key)异或明文1 （（iv+key）+key)异或明文1  （（（iv+key）+key）+key）异或明文3

	优点：与CFB一样，方便传输流数据

	缺点：由于依赖上一次的加密结果，所以并不能并行处理，特性是解密步骤完全一致，因此使用方法上不会有区别。


	** CTR模式： 计算器模式 Counter
	OFB不能并行的原因就在于需要上一次的iv进行加密后的结果，因此在CTR中我们将（iv+key）+key替换成了（iv+1）+key,这样我们就不需要依赖上一次的加密结果了。对比如下:

	OFB
	（iv+key)异或明文1 （（iv+key）+key)异或明文1  （（（iv+key）+key）+key）异或明文3

	CTR
	（iv+key)异或明文1 （（iv+1）+key)异或明文1    （（（iv+1）+1）+key）异或明文3

	优点：由于加解密可以并行，因此CTR模式的加解密速度也很快

	缺点：iv+1的获取比较负责，需要获取瞬时iv

	

	





